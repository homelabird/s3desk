/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/ws": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * WebSocket event stream
         * @description Upgrades to a WebSocket and streams `job.*` events.
         *
         *     If `API_TOKEN` is configured, browsers should pass it via query `?apiToken=...` (WebSocket cannot set custom headers).
         *
         *     Optional: `afterSeq` can be used to replay buffered (non-log) events after a given sequence number.
         */
        get: {
            parameters: {
                query?: {
                    apiToken?: string;
                    afterSeq?: number;
                    /** @description Whether to include `job.log` events in the stream. */
                    includeLogs?: boolean;
                };
                header?: {
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Switching Protocols */
                101: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                401: components["responses"]["ErrorResponse"];
                403: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Server-sent events (SSE) stream
         * @description Streams `job.*` events using `text/event-stream` (one JSON event per `data:` line).
         *
         *     If `API_TOKEN` is configured, browsers should pass it via query `?apiToken=...` (EventSource cannot set custom headers).
         *
         *     Each message includes an SSE `id:` equal to the server-side event `seq`. When reconnecting, clients may send `Last-Event-ID` (or `afterSeq`) to receive buffered (non-log) events that were missed.
         */
        get: {
            parameters: {
                query?: {
                    apiToken?: string;
                    afterSeq?: number;
                    /** @description Whether to include `job.log` events in the stream. */
                    includeLogs?: boolean;
                };
                header?: {
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                    "Last-Event-ID"?: number;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/event-stream": string;
                    };
                };
                401: components["responses"]["ErrorResponse"];
                403: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meta": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Server metadata */
        get: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MetaResponse"];
                    };
                };
                401: components["responses"]["ErrorResponse"];
                403: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/profiles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List profiles */
        get: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Profile"][];
                    };
                };
            };
        };
        put?: never;
        /** Create profile */
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["ProfileCreateRequest"];
                };
            };
            responses: {
                /** @description Created */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Profile"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/profiles/{profileId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete profile */
        delete: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    profileId: components["parameters"]["ProfileId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description No Content */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                404: components["responses"]["ErrorResponse"];
            };
        };
        options?: never;
        head?: never;
        /** Update profile */
        patch: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    profileId: components["parameters"]["ProfileId"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["ProfileUpdateRequest"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Profile"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
            };
        };
        trace?: never;
    };
    "/profiles/{profileId}/test": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Test connectivity/credentials for a profile */
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    profileId: components["parameters"]["ProfileId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ProfileTestResponse"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/profiles/{profileId}/benchmark": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Run a bandwidth benchmark against the profile storage
         * @description Uploads a small test file, downloads it back, then deletes it.
         *     Returns upload/download throughput so users can gauge connection speed.
         */
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    profileId: components["parameters"]["ProfileId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ProfileBenchmarkResponse"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/profiles/{profileId}/export": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Export profile settings as YAML */
        get: {
            parameters: {
                query?: {
                    /** @description When true, send Content-Disposition for file download. */
                    download?: boolean;
                };
                header?: {
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    profileId: components["parameters"]["ProfileId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/yaml": string;
                    };
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/profiles/{profileId}/tls": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get TLS configuration status */
        get: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    profileId: components["parameters"]["ProfileId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ProfileTLSStatus"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
            };
        };
        /** Set TLS configuration */
        put: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    profileId: components["parameters"]["ProfileId"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["ProfileTLSConfig"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ProfileTLSStatus"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
            };
        };
        post?: never;
        /** Delete TLS configuration */
        delete: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    profileId: components["parameters"]["ProfileId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description No Content */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                404: components["responses"]["ErrorResponse"];
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/buckets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List buckets */
        get: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Bucket"][];
                    };
                };
                400: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        /** Create bucket */
        post: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["BucketCreateRequest"];
                };
            };
            responses: {
                /** @description Created */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Bucket"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/buckets/{bucket}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete bucket
         * @description Deletes an empty bucket. If the bucket is not empty, the server returns `409 bucket_not_empty`.
         */
        delete: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    bucket: components["parameters"]["BucketName"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description No Content */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
                409: components["responses"]["ErrorResponse"];
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/buckets/{bucket}/policy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get bucket access policy
         * @description Returns the current provider-specific bucket access policy document if present.
         *
         *     - S3 providers: bucket policy JSON.
         *     - GCS: bucket IAM policy JSON.
         *     - Azure: container access policy JSON.
         *
         *     For buckets/containers with no policy, returns `exists=false`.
         */
        get: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    bucket: components["parameters"]["BucketName"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["BucketPolicyResponse"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
                429: components["responses"]["ErrorResponse"];
                502: components["responses"]["ErrorResponse"];
            };
        };
        /**
         * Put bucket access policy
         * @description Applies provider-specific bucket access policy JSON.
         *
         *     - S3 providers: PutBucketPolicy.
         *     - GCS: Set bucket IAM policy.
         *     - Azure: Set container ACL/public access.
         */
        put: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    bucket: components["parameters"]["BucketName"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["BucketPolicyPutRequest"];
                };
            };
            responses: {
                /** @description No Content */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
                429: components["responses"]["ErrorResponse"];
                502: components["responses"]["ErrorResponse"];
            };
        };
        post?: never;
        /**
         * Delete or reset bucket access policy
         * @description Removes or resets provider-specific access policy state.
         *
         *     - S3 providers: deletes bucket policy.
         *     - Azure: resets container ACL/public access to private + clears stored access policies.
         *     - GCS: delete is not supported; returns `400 bucket_policy_delete_unsupported`.
         */
        delete: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    bucket: components["parameters"]["BucketName"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description No Content */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
                429: components["responses"]["ErrorResponse"];
                502: components["responses"]["ErrorResponse"];
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/buckets/{bucket}/policy/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Validate bucket policy
         * @description Performs static (non-mutating) validation of a provider-specific bucket access policy document.
         *
         *     - For S3 providers, this is syntactic lint only. Real provider validation happens on PUT.
         *     - For GCS/Azure providers, this validates the expected JSON shape for IAM/ACL documents.
         */
        post: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    bucket: components["parameters"]["BucketName"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["BucketPolicyPutRequest"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["BucketPolicyValidateResponse"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/buckets/{bucket}/objects": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List objects and common prefixes (folder-like browsing) */
        get: {
            parameters: {
                query?: {
                    prefix?: string;
                    delimiter?: string;
                    maxKeys?: number;
                    continuationToken?: string;
                };
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    bucket: components["parameters"]["BucketName"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ListObjectsResponse"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        post?: never;
        /**
         * Delete objects (batch)
         * @description For large batches, prefer using a Job.
         */
        delete: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    bucket: components["parameters"]["BucketName"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["DeleteObjectsRequest"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DeleteObjectsResponse"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/buckets/{bucket}/objects/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search objects (indexed)
         * @description Searches a locally stored index of object keys for the given bucket.
         *     If the index has not been created yet, the server returns `409 not_indexed`.
         *     Create the index using the `s3_index_objects` job type.
         */
        get: {
            parameters: {
                query: {
                    q: string;
                    prefix?: string;
                    limit?: number;
                    cursor?: string;
                    ext?: string;
                    minSize?: number;
                    maxSize?: number;
                    modifiedAfter?: string;
                    modifiedBefore?: string;
                };
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    bucket: components["parameters"]["BucketName"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["SearchObjectsResponse"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
                409: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/buckets/{bucket}/objects/index-summary": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get object index summary for a prefix
         * @description Returns an estimate of impact (count/bytes/sample) using the local object index.
         *     If the index has not been created yet, the server returns `409 not_indexed`.
         */
        get: {
            parameters: {
                query?: {
                    prefix?: string;
                    sampleLimit?: number;
                };
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    bucket: components["parameters"]["BucketName"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ObjectIndexSummaryResponse"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
                409: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/buckets/{bucket}/objects/meta": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get object metadata (HEAD) */
        get: {
            parameters: {
                query: {
                    key: string;
                };
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    bucket: components["parameters"]["BucketName"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ObjectMeta"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/buckets/{bucket}/objects/folder": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a folder (prefix marker)
         * @description Creates a zero-byte object whose key ends with `/` so the prefix shows up as a folder in list operations.
         *     If the object already exists, the server returns `409 already_exists`.
         */
        post: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    bucket: components["parameters"]["BucketName"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["CreateFolderRequest"];
                };
            };
            responses: {
                /** @description Created */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["CreateFolderResponse"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
                409: components["responses"]["ErrorResponse"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/buckets/{bucket}/objects/download": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download an object (server proxy)
         * @description Streams an object through this server as an attachment download.
         *     Useful for same-origin downloads (progress/ETA in the UI) and to avoid S3 CORS configuration.
         */
        get: {
            parameters: {
                query: {
                    key: string;
                };
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    bucket: components["parameters"]["BucketName"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/octet-stream": string;
                    };
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/buckets/{bucket}/objects/download-url": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a presigned download URL (GET object)
         * @description Returns a download URL for an object.
         *
         *     By default this uses `rclone link`, which may return a direct (backend) URL.
         *     If `proxy=true`, the server returns a signed proxy URL that enforces
         *     `Content-Disposition` and streams through the backend.
         */
        get: {
            parameters: {
                query: {
                    key: string;
                    expiresSeconds?: number;
                    proxy?: boolean;
                };
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    bucket: components["parameters"]["BucketName"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["PresignedURLResponse"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/download-proxy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download object via signed proxy URL
         * @description Signed URL returned from `/buckets/{bucket}/objects/download-url?proxy=true`.
         *     This endpoint does not require an API token but validates signature + expiry.
         */
        get: {
            parameters: {
                query: {
                    profileId: string;
                    bucket: string;
                    key: string;
                    expires: number;
                    sig: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/octet-stream": string;
                    };
                };
                400: components["responses"]["ErrorResponse"];
                403: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/buckets/{bucket}/objects/favorites": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List favorite objects */
        get: {
            parameters: {
                query?: {
                    prefix?: string;
                };
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    bucket: components["parameters"]["BucketName"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ObjectFavoritesResponse"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        /** Add an object favorite */
        post: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    bucket: components["parameters"]["BucketName"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["ObjectFavoriteCreateRequest"];
                };
            };
            responses: {
                /** @description Created */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ObjectFavorite"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
            };
        };
        /** Remove an object favorite */
        delete: {
            parameters: {
                query: {
                    key: string;
                };
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    bucket: components["parameters"]["BucketName"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description No Content */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                400: components["responses"]["ErrorResponse"];
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/buckets/{bucket}/objects/thumbnail": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an image thumbnail */
        get: {
            parameters: {
                query: {
                    key: string;
                    size?: number;
                };
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    bucket: components["parameters"]["BucketName"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "image/jpeg": string;
                    };
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
                413: components["responses"]["ErrorResponse"];
                415: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/uploads": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create a staging upload session */
        post: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["UploadCreateRequest"];
                };
            };
            responses: {
                /** @description Created */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["UploadCreateResponse"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/uploads/{uploadId}/files": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Upload files to staging (multipart/form-data) */
        post: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    uploadId: components["parameters"]["UploadId"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "multipart/form-data": {
                        files?: string[];
                    };
                };
            };
            responses: {
                /** @description No Content */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
                413: components["responses"]["ErrorResponse"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/uploads/{uploadId}/presign": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Get presigned upload URLs */
        post: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    uploadId: components["parameters"]["UploadId"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["UploadPresignRequest"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["UploadPresignResponse"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/uploads/{uploadId}/chunks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get upload chunk status
         * @description Returns which chunks have been successfully uploaded for a given file within an upload session. Works for both staging and multipart upload modes.
         */
        get: {
            parameters: {
                query: {
                    /** @description Relative file path within the upload session */
                    path: string;
                    /** @description Size of each chunk in bytes */
                    chunkSize: number;
                    /** @description Total file size in bytes */
                    fileSize: number;
                    /** @description Total number of chunks (staging mode only) */
                    total?: number;
                };
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    uploadId: components["parameters"]["UploadId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["UploadChunkState"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
                502: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/uploads/{uploadId}/multipart/complete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Complete a multipart upload */
        post: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    uploadId: components["parameters"]["UploadId"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["UploadMultipartCompleteRequest"];
                };
            };
            responses: {
                /** @description No Content */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/uploads/{uploadId}/multipart/abort": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Abort a multipart upload */
        post: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    uploadId: components["parameters"]["UploadId"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["UploadMultipartAbortRequest"];
                };
            };
            responses: {
                /** @description No Content */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/uploads/{uploadId}/commit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Commit staged files to S3 (creates a Job) */
        post: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    uploadId: components["parameters"]["UploadId"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["UploadCommitRequest"];
                };
            };
            responses: {
                /** @description Job created */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["JobCreatedResponse"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/uploads/{uploadId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Cancel upload session and cleanup staging */
        delete: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    uploadId: components["parameters"]["UploadId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description No Content */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                404: components["responses"]["ErrorResponse"];
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/jobs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List jobs */
        get: {
            parameters: {
                query?: {
                    status?: components["schemas"]["JobStatus"];
                    type?: string;
                    limit?: number;
                    cursor?: string;
                    errorCode?: string;
                };
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["JobsListResponse"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        /** Create job (bulk transfer/sync/etc.) */
        post: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["JobCreateRequest"];
                };
            };
            responses: {
                /** @description Created */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Job"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/jobs/{jobId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get job */
        get: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    jobId: components["parameters"]["JobId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Job"];
                    };
                };
                404: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        post?: never;
        /**
         * Delete job record (and its log file)
         * @description Only allowed for non-active jobs (succeeded/failed/canceled). Cancel queued/running jobs first.
         */
        delete: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    jobId: components["parameters"]["JobId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description No Content */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                404: components["responses"]["ErrorResponse"];
                409: components["responses"]["ErrorResponse"];
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/jobs/{jobId}/artifact": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Download job artifact (zip) */
        get: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    jobId: components["parameters"]["JobId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/zip": string;
                    };
                };
                404: components["responses"]["ErrorResponse"];
                409: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/jobs/{jobId}/logs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get job logs (tail or incremental) */
        get: {
            parameters: {
                query?: {
                    /**
                     * @description If set, reads the log file starting from this byte offset (0-based) and returns up to `maxBytes`.
                     *     Response header `X-Log-Next-Offset` can be used as the next `afterOffset` value.
                     */
                    afterOffset?: number;
                    /** @description Maximum number of bytes to read when using `afterOffset`. */
                    maxBytes?: number;
                    /** @description Number of bytes to read from the end of the log file. */
                    tailBytes?: number;
                };
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    jobId: components["parameters"]["JobId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        /** @description Next byte offset to use as `afterOffset`. */
                        "X-Log-Next-Offset"?: number;
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/jobs/{jobId}/retry": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Retry job (creates a new queued job) */
        post: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    jobId: components["parameters"]["JobId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Created */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Job"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/jobs/{jobId}/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Cancel job */
        post: {
            parameters: {
                query?: never;
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path: {
                    jobId: components["parameters"]["JobId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Job"];
                    };
                };
                404: components["responses"]["ErrorResponse"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/local/entries": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List local directory entries (allowed roots only)
         * @description Lists directories under `ALLOWED_LOCAL_DIRS` for safe local-path selection.
         *     If `path` is omitted, returns the allowed roots.
         *     If `ALLOWED_LOCAL_DIRS` is not configured, the server returns `400 not_configured`.
         */
        get: {
            parameters: {
                query?: {
                    path?: string;
                    limit?: number;
                };
                header: {
                    "X-Profile-Id": components["parameters"]["XProfileId"];
                    /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
                    "X-Api-Token"?: components["parameters"]["XApiToken"];
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ListLocalEntriesResponse"];
                    };
                };
                400: components["responses"]["ErrorResponse"];
                403: components["responses"]["ErrorResponse"];
                404: components["responses"]["ErrorResponse"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        ErrorResponse: {
            error: {
                code: string;
                message: string;
                normalizedError?: components["schemas"]["NormalizedError"];
                details?: {
                    [key: string]: unknown;
                };
            };
        };
        /** @description Provider-agnostic error classifier (primarily derived from rclone stderr). */
        NormalizedError: {
            code: components["schemas"]["NormalizedErrorCode"];
            retryable: boolean;
        };
        /** @enum {string} */
        NormalizedErrorCode: "invalid_credentials" | "access_denied" | "not_found" | "rate_limited" | "network_error" | "invalid_config" | "signature_mismatch" | "request_time_skewed" | "conflict" | "upstream_timeout" | "endpoint_unreachable" | "canceled" | "unknown";
        /**
         * @description Storage provider backend for a profile.
         * @enum {string}
         */
        ProfileProvider: "aws_s3" | "s3_compatible" | "oci_s3_compat" | "azure_blob" | "gcp_gcs" | "oci_object_storage";
        ProfileBase: {
            id: string;
            name: string;
            provider: components["schemas"]["ProfileProvider"];
            preserveLeadingSlash: boolean;
            tlsInsecureSkipVerify: boolean;
            /** Format: date-time */
            createdAt: string;
            /** Format: date-time */
            updatedAt: string;
        };
        ProfileAwsS3: components["schemas"]["ProfileBase"] & {
            /** @enum {string} */
            provider: "aws_s3";
            /** @description Optional. If omitted, uses AWS default endpoint resolution. */
            endpoint?: string;
            region: string;
            forcePathStyle: boolean;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "aws_s3";
        };
        ProfileS3Compatible: components["schemas"]["ProfileBase"] & {
            /** @enum {string} */
            provider: "s3_compatible";
            endpoint: string;
            region: string;
            forcePathStyle: boolean;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "s3_compatible";
        };
        ProfileOciS3Compat: components["schemas"]["ProfileBase"] & {
            /** @enum {string} */
            provider: "oci_s3_compat";
            endpoint: string;
            region: string;
            forcePathStyle: boolean;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "oci_s3_compat";
        };
        ProfileAzureBlob: components["schemas"]["ProfileBase"] & {
            /** @enum {string} */
            provider: "azure_blob";
            accountName: string;
            /** @description Optional. Used for local emulators (Azurite) or custom Azure endpoints. */
            endpoint?: string;
            /** @description Optional. If true and endpoint is omitted, server may choose a default emulator endpoint. */
            useEmulator?: boolean;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "azure_blob";
        };
        ProfileGcpGcs: components["schemas"]["ProfileBase"] & {
            /** @enum {string} */
            provider: "gcp_gcs";
            projectId?: string;
            clientEmail?: string;
            /** @description Optional. Used for local emulators (fake-gcs-server) or custom endpoints. */
            endpoint?: string;
            /** @description Optional. If true, requests are unauthenticated and serviceAccountJson can be omitted. */
            anonymous?: boolean;
            projectNumber?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "gcp_gcs";
        };
        ProfileOciObjectStorage: components["schemas"]["ProfileBase"] & {
            /** @enum {string} */
            provider: "oci_object_storage";
            region: string;
            namespace: string;
            compartment: string;
            endpoint?: string;
            authProvider?: string;
            configFile?: string;
            configProfile?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "oci_object_storage";
        };
        Profile: components["schemas"]["ProfileAwsS3"] | components["schemas"]["ProfileS3Compatible"] | components["schemas"]["ProfileOciS3Compat"] | components["schemas"]["ProfileAzureBlob"] | components["schemas"]["ProfileGcpGcs"] | components["schemas"]["ProfileOciObjectStorage"];
        ProfileCreateRequestAwsS3: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "aws_s3";
            name: string;
            /** @description Optional. If omitted, uses AWS default endpoint resolution. */
            endpoint?: string;
            region: string;
            accessKeyId: string;
            secretAccessKey: string;
            sessionToken?: string | null;
            /** @default false */
            forcePathStyle: boolean;
            /** @default false */
            preserveLeadingSlash: boolean;
            /** @default false */
            tlsInsecureSkipVerify: boolean;
        };
        ProfileCreateRequestS3Compatible: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "s3_compatible";
            name: string;
            endpoint: string;
            region: string;
            accessKeyId: string;
            secretAccessKey: string;
            sessionToken?: string | null;
            /** @default false */
            forcePathStyle: boolean;
            /** @default false */
            preserveLeadingSlash: boolean;
            /** @default false */
            tlsInsecureSkipVerify: boolean;
        };
        ProfileCreateRequestOciS3Compat: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "oci_s3_compat";
            name: string;
            endpoint: string;
            region: string;
            accessKeyId: string;
            secretAccessKey: string;
            sessionToken?: string | null;
            /** @default false */
            forcePathStyle: boolean;
            /** @default false */
            preserveLeadingSlash: boolean;
            /** @default false */
            tlsInsecureSkipVerify: boolean;
        };
        ProfileCreateRequestAzureBlob: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "azure_blob";
            name: string;
            accountName: string;
            accountKey: string;
            /** @description Optional. Used for local emulators (Azurite) or custom Azure endpoints. */
            endpoint?: string;
            /** @description Optional. If true and endpoint is omitted, server may choose a default emulator endpoint. */
            useEmulator?: boolean;
            /** @default false */
            preserveLeadingSlash: boolean;
            /** @default false */
            tlsInsecureSkipVerify: boolean;
        };
        ProfileCreateRequestGcpGcs: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "gcp_gcs";
            name: string;
            /** @description GCP service account JSON. Required unless anonymous=true. */
            serviceAccountJson?: string;
            /** @description If true, requests are unauthenticated and serviceAccountJson can be omitted. */
            anonymous?: boolean;
            /** @description Optional. Used for local emulators (fake-gcs-server) or custom endpoints. */
            endpoint?: string;
            projectNumber?: string;
            /** @default false */
            preserveLeadingSlash: boolean;
            /** @default false */
            tlsInsecureSkipVerify: boolean;
        };
        ProfileCreateRequestOciObjectStorage: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "oci_object_storage";
            name: string;
            region: string;
            namespace: string;
            compartment: string;
            endpoint?: string;
            authProvider?: string;
            configFile?: string;
            configProfile?: string;
            /** @default false */
            preserveLeadingSlash: boolean;
            /** @default false */
            tlsInsecureSkipVerify: boolean;
        };
        ProfileCreateRequest: components["schemas"]["ProfileCreateRequestAwsS3"] | components["schemas"]["ProfileCreateRequestS3Compatible"] | components["schemas"]["ProfileCreateRequestOciS3Compat"] | components["schemas"]["ProfileCreateRequestAzureBlob"] | components["schemas"]["ProfileCreateRequestGcpGcs"] | components["schemas"]["ProfileCreateRequestOciObjectStorage"];
        ProfileUpdateRequestAwsS3: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "aws_s3";
            name?: string;
            endpoint?: string;
            region?: string;
            accessKeyId?: string;
            secretAccessKey?: string;
            /** @description Set to empty string to clear; omit to keep unchanged. */
            sessionToken?: string | null;
            forcePathStyle?: boolean;
            preserveLeadingSlash?: boolean;
            tlsInsecureSkipVerify?: boolean;
        };
        ProfileUpdateRequestS3Compatible: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "s3_compatible";
            name?: string;
            endpoint?: string;
            region?: string;
            accessKeyId?: string;
            secretAccessKey?: string;
            /** @description Set to empty string to clear; omit to keep unchanged. */
            sessionToken?: string | null;
            forcePathStyle?: boolean;
            preserveLeadingSlash?: boolean;
            tlsInsecureSkipVerify?: boolean;
        };
        ProfileUpdateRequestOciS3Compat: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "oci_s3_compat";
            name?: string;
            endpoint?: string;
            region?: string;
            accessKeyId?: string;
            secretAccessKey?: string;
            /** @description Set to empty string to clear; omit to keep unchanged. */
            sessionToken?: string | null;
            forcePathStyle?: boolean;
            preserveLeadingSlash?: boolean;
            tlsInsecureSkipVerify?: boolean;
        };
        ProfileUpdateRequestAzureBlob: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "azure_blob";
            name?: string;
            accountName?: string;
            accountKey?: string;
            /** @description Optional. Used for local emulators (Azurite) or custom Azure endpoints. */
            endpoint?: string;
            /** @description Optional. If true and endpoint is omitted, server may choose a default emulator endpoint. */
            useEmulator?: boolean;
            preserveLeadingSlash?: boolean;
            tlsInsecureSkipVerify?: boolean;
        };
        ProfileUpdateRequestGcpGcs: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "gcp_gcs";
            name?: string;
            serviceAccountJson?: string;
            /** @description If true, requests are unauthenticated and serviceAccountJson can be omitted. */
            anonymous?: boolean;
            /** @description Optional. Used for local emulators (fake-gcs-server) or custom endpoints. */
            endpoint?: string;
            projectNumber?: string;
            preserveLeadingSlash?: boolean;
            tlsInsecureSkipVerify?: boolean;
        };
        ProfileUpdateRequestOciObjectStorage: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "oci_object_storage";
            name?: string;
            region?: string;
            namespace?: string;
            compartment?: string;
            endpoint?: string;
            authProvider?: string;
            configFile?: string;
            configProfile?: string;
            preserveLeadingSlash?: boolean;
            tlsInsecureSkipVerify?: boolean;
        };
        ProfileUpdateRequest: components["schemas"]["ProfileUpdateRequestAwsS3"] | components["schemas"]["ProfileUpdateRequestS3Compatible"] | components["schemas"]["ProfileUpdateRequestOciS3Compat"] | components["schemas"]["ProfileUpdateRequestAzureBlob"] | components["schemas"]["ProfileUpdateRequestGcpGcs"] | components["schemas"]["ProfileUpdateRequestOciObjectStorage"];
        ProfileTestResponse: {
            ok: boolean;
            message?: string;
            /**
             * @description Additional test metadata.
             *     Known keys:
             *       - buckets: number of buckets returned by ListBuckets.
             *       - storageType: detected storage type (ceph, aws-s3, s3-compatible, unknown).
             *       - storageTypeSource: detection source (server-header, endpoint, default, none).
             *       - error: error string when ok=false.
             */
            details?: {
                [key: string]: unknown;
            };
        };
        ProfileBenchmarkResponse: {
            ok: boolean;
            message?: string;
            /**
             * Format: int64
             * @description Upload throughput in bits per second.
             */
            uploadBps?: number | null;
            /**
             * Format: int64
             * @description Download throughput in bits per second.
             */
            downloadBps?: number | null;
            /**
             * Format: int64
             * @description Upload duration in milliseconds.
             */
            uploadMs?: number | null;
            /**
             * Format: int64
             * @description Download duration in milliseconds.
             */
            downloadMs?: number | null;
            /**
             * Format: int64
             * @description Size of the test file in bytes.
             */
            fileSizeBytes?: number | null;
            /** @description Whether the test file was successfully deleted. */
            cleanedUp: boolean;
        };
        /** @enum {string} */
        ProfileTLSMode: "disabled" | "mtls";
        ProfileTLSConfig: {
            mode: components["schemas"]["ProfileTLSMode"];
            clientCertPem?: string;
            clientKeyPem?: string;
            caCertPem?: string;
        };
        ProfileTLSStatus: {
            mode: components["schemas"]["ProfileTLSMode"];
            hasClientCert: boolean;
            hasClientKey: boolean;
            hasCa: boolean;
            /** Format: date-time */
            updatedAt?: string;
        };
        Bucket: {
            name: string;
            /** Format: date-time */
            createdAt?: string;
        };
        BucketCreateRequest: {
            name: string;
            region?: string;
        };
        BucketPolicyResponse: {
            bucket: string;
            exists: boolean;
            /**
             * @description Bucket access policy document.
             *
             *     - S3 providers: S3 bucket policy JSON.
             *     - GCS: bucket IAM policy JSON (bindings).
             *     - Azure: container public access + stored access policy JSON.
             */
            policy?: {
                [key: string]: unknown;
            } | null;
        };
        BucketPolicyPutRequest: {
            /** @description Bucket access policy document (provider-specific). */
            policy: {
                [key: string]: unknown;
            };
        };
        BucketPolicyValidateResponse: {
            ok: boolean;
            provider: components["schemas"]["ProfileProvider"];
            errors?: string[];
            warnings?: string[];
        };
        ObjectItem: {
            key: string;
            /** Format: int64 */
            size: number;
            etag?: string;
            /** Format: date-time */
            lastModified: string;
            storageClass?: string;
        };
        ObjectFavorite: {
            key: string;
            /** Format: date-time */
            createdAt: string;
        };
        ObjectFavoriteCreateRequest: {
            key: string;
        };
        FavoriteObjectItem: components["schemas"]["ObjectItem"] & {
            /** Format: date-time */
            createdAt: string;
        };
        ObjectFavoritesResponse: {
            bucket: string;
            prefix?: string;
            items: components["schemas"]["FavoriteObjectItem"][];
        };
        ListObjectsResponse: {
            bucket: string;
            prefix: string;
            delimiter: string;
            commonPrefixes: string[];
            items: components["schemas"]["ObjectItem"][];
            nextContinuationToken?: string | null;
            isTruncated: boolean;
        };
        SearchObjectsResponse: {
            bucket: string;
            query: string;
            prefix?: string;
            items: components["schemas"]["ObjectItem"][];
            nextCursor?: string | null;
        };
        ObjectIndexSummaryResponse: {
            bucket: string;
            prefix?: string;
            /** Format: int64 */
            objectCount: number;
            /** Format: int64 */
            totalBytes: number;
            sampleKeys: string[];
            /** Format: date-time */
            indexedAt?: string | null;
        };
        LocalEntry: {
            name: string;
            path: string;
            isDir: boolean;
        };
        ListLocalEntriesResponse: {
            basePath?: string;
            entries: components["schemas"]["LocalEntry"][];
        };
        ObjectMeta: {
            key: string;
            /** Format: int64 */
            size?: number;
            etag?: string;
            /** Format: date-time */
            lastModified?: string;
            contentType?: string;
            metadata?: {
                [key: string]: string;
            };
        };
        PresignedURLResponse: {
            /** Format: uri */
            url: string;
            /** Format: date-time */
            expiresAt: string;
        };
        CreateFolderRequest: {
            /** @description Object key ending with `/` */
            key: string;
        };
        CreateFolderResponse: {
            key: string;
        };
        DeleteObjectsRequest: {
            keys: string[];
        };
        DeleteObjectsResponse: {
            deleted: number;
        };
        UploadCreateRequest: {
            bucket: string;
            /** @default  */
            prefix: string;
            /**
             * @default staging
             * @enum {string}
             */
            mode: "staging" | "direct" | "presigned";
        };
        UploadCreateResponse: {
            uploadId: string;
            /** @enum {string} */
            mode: "staging" | "direct" | "presigned";
            /** Format: int64 */
            maxBytes?: number | null;
            /** Format: date-time */
            expiresAt: string;
        };
        UploadCommitItem: {
            path: string;
            /** Format: int64 */
            size?: number;
        };
        UploadCommitRequest: {
            label?: string;
            rootName?: string;
            /** @enum {string} */
            rootKind?: "file" | "folder" | "collection";
            totalFiles?: number;
            /** Format: int64 */
            totalBytes?: number;
            items?: components["schemas"]["UploadCommitItem"][];
            itemsTruncated?: boolean;
        };
        UploadPresignRequest: {
            path: string;
            contentType?: string;
            /** Format: int64 */
            size?: number;
            expiresSeconds?: number;
            multipart?: components["schemas"]["UploadMultipartPresignReq"];
        };
        UploadMultipartPresignReq: {
            /** Format: int64 */
            fileSize?: number;
            /** Format: int64 */
            partSizeBytes?: number;
            partNumbers?: number[];
        };
        UploadPresignResponse: {
            /** @enum {string} */
            mode: "single" | "multipart";
            bucket: string;
            key: string;
            method?: string;
            url?: string;
            headers?: {
                [key: string]: string;
            };
            /** Format: date-time */
            expiresAt: string;
            multipart?: components["schemas"]["UploadPresignMultipart"];
        };
        UploadPresignMultipart: {
            uploadId: string;
            /** Format: int64 */
            partSizeBytes: number;
            partCount: number;
            parts?: components["schemas"]["UploadPresignPart"][];
        };
        UploadPresignPart: {
            number: number;
            method?: string;
            url: string;
            headers?: {
                [key: string]: string;
            };
        };
        UploadChunkState: {
            /** @description Zero-based indices of chunks that have been successfully uploaded */
            present: number[];
        };
        UploadMultipartCompleteRequest: {
            path: string;
            parts: components["schemas"]["UploadMultipartCompletePart"][];
        };
        UploadMultipartCompletePart: {
            number: number;
            etag: string;
        };
        UploadMultipartAbortRequest: {
            path: string;
        };
        /** @enum {string} */
        JobStatus: "queued" | "running" | "succeeded" | "failed" | "canceled";
        /**
         * @description Supported job types.
         * @enum {string}
         */
        JobType: "transfer_sync_local_to_s3" | "transfer_sync_staging_to_s3" | "transfer_sync_s3_to_local" | "transfer_delete_prefix" | "s3_zip_prefix" | "s3_zip_objects" | "s3_delete_objects" | "s3_index_objects" | "transfer_copy_object" | "transfer_move_object" | "transfer_copy_batch" | "transfer_move_batch" | "transfer_copy_prefix" | "transfer_move_prefix";
        TransferSyncLocalToS3Payload: {
            bucket: string;
            /** @default  */
            prefix: string;
            localPath: string;
            /** @default false */
            deleteExtraneous: boolean;
            include?: string[];
            exclude?: string[];
            /** @default false */
            dryRun: boolean;
        };
        TransferSyncStagingToS3Payload: {
            uploadId: string;
            bucket?: string;
            prefix?: string;
            label?: string;
            rootName?: string;
            /** @enum {string} */
            rootKind?: "file" | "folder" | "collection";
            totalFiles?: number;
            /** Format: int64 */
            totalBytes?: number;
            items?: components["schemas"]["TransferSyncStagingToS3Item"][];
            itemsTruncated?: boolean;
        };
        TransferSyncStagingToS3Item: {
            path: string;
            key: string;
            /** Format: int64 */
            size?: number;
        };
        TransferSyncS3ToLocalPayload: {
            bucket: string;
            /** @default  */
            prefix: string;
            /** @description Local destination directory path */
            localPath: string;
            /**
             * @description Delete local files that are not in S3 (sync mode).
             * @default false
             */
            deleteExtraneous: boolean;
            include?: string[];
            exclude?: string[];
            /** @default false */
            dryRun: boolean;
        };
        /** @description Either provide `prefix` (recommended to end with `/`) or set `deleteAll=true` to delete all objects in the bucket. */
        TransferDeletePrefixPayload: {
            bucket: string;
            /** @default  */
            prefix: string;
            /** @default false */
            deleteAll: boolean;
            /** @default false */
            allowUnsafePrefix: boolean;
            include?: string[];
            exclude?: string[];
            /** @default false */
            dryRun: boolean;
        };
        S3ZipPrefixPayload: {
            bucket: string;
            /**
             * @description Prefix to zip (optional).
             * @default
             */
            prefix: string;
        };
        S3ZipObjectsPayload: {
            bucket: string;
            keys: string[];
            /**
             * @description If set, removes this prefix from object keys inside the zip.
             * @default
             */
            stripPrefix: string;
        };
        S3DeleteObjectsPayload: {
            bucket: string;
            keys: string[];
        };
        S3IndexObjectsPayload: {
            bucket: string;
            /** @default  */
            prefix: string;
            /**
             * @description Clear existing index entries for this bucket/prefix before indexing.
             * @default true
             */
            fullReindex: boolean;
        };
        TransferCopyObjectPayload: {
            srcBucket: string;
            srcKey: string;
            dstBucket: string;
            dstKey: string;
            /** @default false */
            dryRun: boolean;
        };
        TransferMoveObjectPayload: {
            srcBucket: string;
            srcKey: string;
            dstBucket: string;
            dstKey: string;
            /** @default false */
            dryRun: boolean;
        };
        TransferBatchItem: {
            srcKey: string;
            dstKey: string;
        };
        TransferCopyBatchPayload: {
            srcBucket: string;
            dstBucket: string;
            items: components["schemas"]["TransferBatchItem"][];
            /** @default false */
            dryRun: boolean;
        };
        TransferMoveBatchPayload: {
            srcBucket: string;
            dstBucket: string;
            items: components["schemas"]["TransferBatchItem"][];
            /** @default false */
            dryRun: boolean;
        };
        TransferCopyPrefixPayload: {
            srcBucket: string;
            /** @description Must end with `/` */
            srcPrefix: string;
            dstBucket: string;
            /** @default  */
            dstPrefix: string;
            include?: string[];
            exclude?: string[];
            /** @default false */
            dryRun: boolean;
        };
        TransferMovePrefixPayload: {
            srcBucket: string;
            /** @description Must end with `/` */
            srcPrefix: string;
            dstBucket: string;
            /** @default  */
            dstPrefix: string;
            include?: string[];
            exclude?: string[];
            /** @default false */
            dryRun: boolean;
        };
        JobCreateRequestTransferSyncLocalToS3: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "transfer_sync_local_to_s3";
            payload: components["schemas"]["TransferSyncLocalToS3Payload"];
        };
        JobCreateRequestTransferSyncStagingToS3: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "transfer_sync_staging_to_s3";
            payload: components["schemas"]["TransferSyncStagingToS3Payload"];
        };
        JobCreateRequestTransferSyncS3ToLocal: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "transfer_sync_s3_to_local";
            payload: components["schemas"]["TransferSyncS3ToLocalPayload"];
        };
        JobCreateRequestTransferDeletePrefix: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "transfer_delete_prefix";
            payload: components["schemas"]["TransferDeletePrefixPayload"];
        };
        JobCreateRequestS3ZipPrefix: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "s3_zip_prefix";
            payload: components["schemas"]["S3ZipPrefixPayload"];
        };
        JobCreateRequestS3ZipObjects: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "s3_zip_objects";
            payload: components["schemas"]["S3ZipObjectsPayload"];
        };
        JobCreateRequestS3DeleteObjects: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "s3_delete_objects";
            payload: components["schemas"]["S3DeleteObjectsPayload"];
        };
        JobCreateRequestS3IndexObjects: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "s3_index_objects";
            payload: components["schemas"]["S3IndexObjectsPayload"];
        };
        JobCreateRequestTransferCopyObject: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "transfer_copy_object";
            payload: components["schemas"]["TransferCopyObjectPayload"];
        };
        JobCreateRequestTransferMoveObject: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "transfer_move_object";
            payload: components["schemas"]["TransferMoveObjectPayload"];
        };
        JobCreateRequestTransferCopyBatch: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "transfer_copy_batch";
            payload: components["schemas"]["TransferCopyBatchPayload"];
        };
        JobCreateRequestTransferMoveBatch: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "transfer_move_batch";
            payload: components["schemas"]["TransferMoveBatchPayload"];
        };
        JobCreateRequestTransferCopyPrefix: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "transfer_copy_prefix";
            payload: components["schemas"]["TransferCopyPrefixPayload"];
        };
        JobCreateRequestTransferMovePrefix: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "transfer_move_prefix";
            payload: components["schemas"]["TransferMovePrefixPayload"];
        };
        JobProgress: {
            /** Format: int64 */
            objectsDone?: number;
            /** Format: int64 */
            objectsTotal?: number | null;
            /** Format: int64 */
            objectsPerSecond?: number | null;
            /** Format: int64 */
            bytesDone?: number;
            /** Format: int64 */
            bytesTotal?: number | null;
            /** Format: int64 */
            speedBps?: number | null;
            etaSeconds?: number | null;
        };
        Job: {
            id: string;
            type: components["schemas"]["JobType"];
            status: components["schemas"]["JobStatus"];
            payload: {
                [key: string]: unknown;
            };
            progress?: components["schemas"]["JobProgress"];
            error?: string | null;
            errorCode?: string | null;
            /** Format: date-time */
            createdAt: string;
            /** Format: date-time */
            startedAt?: string | null;
            /** Format: date-time */
            finishedAt?: string | null;
        };
        JobCreateRequest: components["schemas"]["JobCreateRequestTransferSyncLocalToS3"] | components["schemas"]["JobCreateRequestTransferSyncStagingToS3"] | components["schemas"]["JobCreateRequestTransferSyncS3ToLocal"] | components["schemas"]["JobCreateRequestTransferDeletePrefix"] | components["schemas"]["JobCreateRequestS3ZipPrefix"] | components["schemas"]["JobCreateRequestS3ZipObjects"] | components["schemas"]["JobCreateRequestS3DeleteObjects"] | components["schemas"]["JobCreateRequestS3IndexObjects"] | components["schemas"]["JobCreateRequestTransferCopyObject"] | components["schemas"]["JobCreateRequestTransferMoveObject"] | components["schemas"]["JobCreateRequestTransferCopyBatch"] | components["schemas"]["JobCreateRequestTransferMoveBatch"] | components["schemas"]["JobCreateRequestTransferCopyPrefix"] | components["schemas"]["JobCreateRequestTransferMovePrefix"];
        JobCreatedResponse: {
            jobId: string;
        };
        JobsListResponse: {
            items: components["schemas"]["Job"][];
            nextCursor?: string | null;
        };
        MetaResponse: {
            version: string;
            serverAddr: string;
            dataDir: string;
            staticDir: string;
            apiTokenEnabled: boolean;
            encryptionEnabled: boolean;
            capabilities: components["schemas"]["MetaCapabilities"];
            allowedLocalDirs?: string[];
            jobConcurrency: number;
            /** Format: int64 */
            jobLogMaxBytes?: number | null;
            /** Format: int64 */
            jobRetentionSeconds?: number | null;
            /** Format: int64 */
            jobLogRetentionSeconds?: number | null;
            /** Format: int64 */
            uploadSessionTTLSeconds: number;
            /** Format: int64 */
            uploadMaxBytes?: number | null;
            uploadDirectStream?: boolean;
            transferEngine: {
                name: string;
                available: boolean;
                compatible: boolean;
                minVersion: string;
                path?: string;
                version?: string;
            };
        };
        MetaCapabilities: {
            profileTls: components["schemas"]["FeatureCapability"];
            providers?: {
                [key: string]: components["schemas"]["ProviderCapability"];
            };
        };
        FeatureCapability: {
            enabled: boolean;
            reason?: string;
        };
        ProviderCapability: {
            bucketCrud: boolean;
            objectCrud: boolean;
            jobTransfer: boolean;
            bucketPolicy: boolean;
            gcsIamPolicy: boolean;
            azureContainerAccessPolicy: boolean;
            presignedUpload: boolean;
            presignedMultipartUpload: boolean;
            directUpload: boolean;
            reasons?: components["schemas"]["ProviderCapabilityReasons"];
        };
        ProviderCapabilityReasons: {
            bucketCrud?: string;
            objectCrud?: string;
            jobTransfer?: string;
            bucketPolicy?: string;
            gcsIamPolicy?: string;
            azureContainerAccessPolicy?: string;
            presignedUpload?: string;
            presignedMultipartUpload?: string;
            directUpload?: string;
        };
    };
    responses: {
        /** @description Error */
        ErrorResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
    };
    parameters: {
        XProfileId: string;
        /** @description Optional local API token to mitigate localhost/CSRF style attacks. */
        XApiToken: string;
        ProfileId: string;
        BucketName: string;
        UploadId: string;
        JobId: string;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
